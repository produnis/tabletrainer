---
description: "Lösungswege zu den Übungsaufgaben für das data.table Paket"
format:
  buechlein-html:
    include-in-header: "vgwort/loesungen.html"
    #aliases: 
    #- Kapitel-Tidyverse.html
---

# Lösungswege {#sec-LoesungAnfang}

::: {.callout-warning appearance="simple"}
Gerade als Anfänger:in sollten Sie zumindest *versuchen*, die Aufgaben selbstständig zu lösen, bevor Sie sich die Lösungswege anschauen. Kopf hoch, Sie schaffen das!
:::

::: {.callout-tip appearance="default"}
## Cheat Sheet
Auf GitHub ist ein schöner Cheat-Sheet für `data.table` vorhanden, der bei der Lösung der Aufgaben hilfreich sein könnte. Das PDF können Sie unter <https://raw.githubusercontent.com/rstudio/cheatsheets/master/datatable.pdf>  herunterladen.

:::


## Lösung zur Aufgabe [-@sec-AAA00] Größe und Gewicht {#sec-LAA00}
::: {.callout-tip}
## a) Überführen Sie die Daten in eine `data.table` mit den Variablen `Groesse` und `Gewicht`.

```{r}
#| label: LoesungAA00a
# Paket aktivieren
library(data.table)

# Überführe in eine data.table
dt <- data.table(Groesse = c(1.68, 1.87, 1.95, 1.74, 1.80, 1.75, 1.59, 
                             1.77, 1.82, 1.74),
                 Gewicht = c(78500, 110100, 97500, 69200, 82500, 71500, 
                             81500, 87200, 75500, 65500)
)

# anzeigen
dt
```

:::

\smallskip\  

::: {.callout-tip}
## b) Rechnen Sie das Gewicht um in Kilogramm, und speichern Sie Ihr Ergebnis in der neuen Variable `Kilogramm`

```{r}
#| label: LoesungAA00b
# Umrechnen in Kilogramm
dt[, Kilogramm := Gewicht / 1000]

# anzeigen
dt
```

:::

\smallskip\  

::: {.callout-tip}
## c) Lassen Sie die Daten von Proband 4, 7 und 9 ausgeben

```{r}
#| label: LoesungAA00c
# Ausgabe der Daten von Proband 4, 7 und 9
dt[c(4, 7, 9)]
```

:::

\smallskip\  

::: {.callout-tip}
## d) Lassen Sie die Daten der Probanden ausgeben, deren Gewicht größer ist als 80kg

```{r}
#| label: LoesungAA00d
dt[Kilogramm > 80]
```

:::

\smallskip\  

::: {.callout-tip}
## e) Lassen Sie die Daten der Probanden ausgeben, die größer als 1,7m sind und leichter als 85kg

```{r}
#| label: LoesungAA00e
dt[Groesse > 1.7 & Kilogramm < 85]
```

:::



\smallskip\  

::: {.callout-tip}
## f) Speichern Sie Ihr `data.table`-Objekt in die Datei `groegew.csv`. Lassen Sie sich dabei zunächst anzeigen, was in die Datei geschrieben werden wird.

```{r}
#| label: LoesungAA00f
# zeige, was in die Datei gespeichert würde
fwrite(dt)
```

```{r}
#| label: LoesungAA00fb
#| eval: false
# speichere in Datei groegew.csv
fwrite(dt, "groegew.csv")

```

:::





\smallskip\  

\newpage

## Lösung zur Aufgabe [-@sec-AAA01] Datentabelle {#sec-LAA01}
::: {.callout-tip}
## a) Übertragen Sie die Daten in eine `data.table` mit dem Namen `chol`.

```{r}
#| label: LoesungAA01a
# übertrage die Daten
chol <- data.table(Name = c("Anna Tomie", "Bud Zillus", "Dieter Mietenplage", 
                            "Hella Scheinwerfer", "Inge Danken", "Jason Zufall"),
                   Geschlecht = c("W", "M", "M", "W", "W", "M"),
                   Gewicht = c(85, 115, 79, 60, 57, 96),
                   Größe = c(179, 173, 181, 170, 158, 174),
                   Cholesterol = c(182, 232, 191, 200, 148, 249)
)
# anzeigen
chol
```

:::

\smallskip\  

::: {.callout-tip}
## b) Erstellen Sie eine neue Variable `Alter`, die zwischen `Name` und `Geschlecht` liegt

```{r}
#| label: LoesungAA01b

# Alter der Probanden
alter <- c(18, 32, 24, 35, 46, 68)

# Neue Spalte 'Alter' 
chol[, Alter := alter]

# Spalte 'Alter' zwischen `Name` und `Geschlecht`
setcolorder(chol, c("Name", "Alter", "Geschlecht", "Gewicht", 
                    "Größe", "Cholesterol"))

# Ausgabe der data.table
chol
```

:::

\smallskip\  

::: {.callout-tip}
## c) Fügen Sie einen weiteren Fall mit folgenden Daten dem Datenframe hinzu

```{r}
#| label: LoesungAA01c
# Neuer Fall
neu <- data.table(Name = "Mitch Mackes",
                  Alter = 44,
                  Geschlecht = "M",
                  Gewicht = 92,
                  Größe = 178,
                  Cholesterol = 220
)

# mit rbind zusammenbringen
chol <- rbind(chol, neu)

# anzeigen
chol

```

:::

\smallskip\  

::: {.callout-tip}
## d) Erzeugen Sie eine neue Variable `BMI`.

```{r}
#| label: LoesungAA01d
# BMI berechnen
chol[, BMI := Gewicht / (Größe / 100)^2]

# anzeigen
chol

```

:::

\smallskip\  

::: {.callout-tip}
## e) Fügen Sie die Variable `Adipositas` hinzu, in welcher Sie die `BMI`-Werte wie folgt klassieren

Hierzu können wir entweder die `fifelse()`-Funktion nutzen...

```{r}
#| label: LoesungAA01e1
# Klassifizieren mit fifelse
chol[, Adipositas := fifelse(BMI < 18.5, "Untergewicht",
                     fifelse(BMI >= 18.5 & BMI < 24.5, "Normalgewicht",
                     fifelse(BMI >= 24.5 & BMI <= 30, "Übergewicht", "Adipositas")))]

# anzeigen
chol
```


...oder mittels `cut()`.

```{r}
#| label: LoesungAA01e2
# Klassifizieren mit cut()
chol[, Adipositas := cut(BMI, 
                         breaks = c(-Inf, 18.5, 24.5, 30, Inf), 
                         labels = c("Untergewicht", "Normalgewicht", 
                                    "Übergewicht", "Adipositas"))]
# anzeigen
chol
```

:::

\smallskip\  

::: {.callout-tip}
## f) Filtern Sie Ihren Datensatz, so dass Sie einen neuen Datensatz `male` erhalten, welcher nur die Daten der Männer beinhaltet.


```{r}
#| label: LoesungAA01f
male <- chol[Geschlecht == "M"]

# anzeigen
male
```

:::



\smallskip\  

::: {.callout-tip}
## g) Speichern Sie die Objekte `chol` und `male` als Textdatei auf Ihre Festplatte. Lassen Sie sich dabei jeweils zuvor anzeigen, welcher Inhalt in die Textdatei geschrieben werden wird.


```{r}
#| label: LoesungAA01g
# zeige, was in chol.txt gespeichert würde
fwrite(chol)

# zeige, was in male.txt gespeichert würde
fwrite(male)
```

```{r}
#| label: LoesungAA01g2
#| eval: false
# speichere in Datei chol.txt
fwrite(chol, "chol.txt")


# speichere in Datei male.txt
fwrite(male, "male.txt")
```

:::





\smallskip\  


## Lösung zur Aufgabe [-@sec-AAA02] Big Five {#sec-LAA02}
```{r}
#| label: LoesungAA02aSETUP
#| echo: false
big5 <- fread(cmd = 'unzip -p data/big_five.zip big_five_scores.csv')
```


:::: {.callout-tip}
## a) Lesen Sie den Datensatz  `big_five_scores.csv` als `data.table` in Ihre `R`-Session.

Zunächst laden wir die Datei von  <https://www.produnis.de/tabletrainer/big_five.zip> herunter und legen sie im `data`-Ordner (siehe @sec-Vorbereitungen) ab.

Wenn Sie dies bereits getan haben und die Datei `big_five_scores.csv` bereits entpackt ist, lautet der Befehl zum Einlesen der Daten:
```{r}
#| label: LoesungAA02aDefault
#| eval: false
# lese Daten ein
big5 <- fread("data/big_five_scores.csv")
```

Wir können die Datei aber auch direkt in `R` herunterladen und entpacken.

```{r}
#| label: LoesungAA02aDownload
#| eval: false
# File herunterladen und im "data" Ordner speichern
download.file("https://www.produnis.de/tabletrainer/data/big_five.zip", 
              destfile = "data/testbig_five.zip")

# entpacken in temporäres Verzeichnis
unzip("data/big_five.zip", 
      files = "big_five_scores.csv", 
      exdir = tempdir())

# speichere Pfad auf temporäre Datei
pfad <- file.path(tempdir(), "big_five_scores.csv")
```

Der Befehl zum Einlesen aus der temporären Datei lautet
```{r}
#| label: LoesungAA02aTempEinlesen
#| eval: false
fread(pfad)
```


::: {.callout-caution appearance="minimal"}

Falls Sie das `unzip` Programm auf Ihrem PC installiert haben, können Sie direkt auf das ZIP-Paket zugreifen
```{r}
#| label: LoesungAA02aUnzip
#| eval: false
fread(cmd = 'unzip -p data/big_five.zip big_five_scores.csv')
```

Wenn das ZIP-Paket nur eine Datei enthält, muss dessen Dateiname nicht extra angegeben werden.
```{r}
#| label: LoesungAA02aUnzip2
#| eval: false
fread(cmd = 'unzip -p data/big_five.zip')
```

:::

Mit dem Datensatz vertraut machen:
```{r}
#| label: LoesungAA02astr
str(big5)
```

::::

\smallskip\  


:::: {.callout-tip}
## b) Ändern Sie die Geschlechtskodierung, so dass `männlich` und `weiblich` verwendet werden.

```{r}
#| label: LoesungAA02b
# Ändere die Geschlechtskodierung
big5[, sex := fifelse(sex == 1, "männlich", "weiblich")]

str(big5)
```

:::


\smallskip\  

:::: {.callout-tip}
## c) Passen Sie das Skalenniveau der Variablen an.

```{r}
#| label: LoesungAA02c
# case_id und country sind nominale Variablen
big5[, let(case_id = factor(case_id),
           country = factor(country),
           sex     = factor(sex)
          )]

str(big5)
```

:::

\smallskip\  


## Lösung zur Aufgabe [-@sec-AAA03] Rolling Stone Magazine {#sec-LAA03}

:::: {.callout-tip}
# a) Laden Sie die Datei `rolling_stone.csv`  als `data.table` in Ihre `R`-Session und machen Sie sich mit dem Datensatz vertraut.
```{r}
#| label: LoesungAA03SETUP
#| echo: false
rs <- fread("data/rolling_stone.csv")

```

```{r}
#| label: LoesungAA03a
#| eval: false
# falls schon gedownloadet
rs <- fread("data/rolling_stone.csv")

# per URL einlesen
rs <- fread("https://www.produnis.de/tabletrainer/data/rolling_stone.csv")
```


```{r}
#| label: LoesungAA03a2
# anschauen
str(rs)
```

::::


\smallskip\  


:::: {.callout-tip}
# b) Passen Sie das Skalenniveau der Variablen an.

Es gibt einige kategoriale Variablen im Datensatz.

```{r}
#| label: LoesungAA03b
rs[, let(sort_name = factor(sort_name),
         clean_name = factor(clean_name),
         album = factor(album),
         genre = factor(genre),
         type  = factor(type),
         artist_gender  = factor(artist_gender),
         album_id  = factor(album_id),
         spotify_url  = factor(spotify_url)
        )]

# anschauen
str(rs)
```
::::

\smallskip\  

:::: {.callout-tip}
# c) Welche sind die Nummer 1 Alben der Jahre 2003, 2012 und 2020?


```{r}
#| label: LoesungAA03c
rs[rank_2003 == 1 | rank_2012 == 1 | rank_2020 == 1,
  .(clean_name, album, rank_2003, rank_2012, rank_2020)
]
```
::::

\smallskip\  


:::: {.callout-tip}
# d) Ist Ihre Lieblingsband in der Liste?

Angenommen, meine Lieblingsband sei *Faith No More*.
```{r}
#| label: LoesungAA03d
rs[clean_name == "Faith No More"]
```
Die ist leider nicht enthalten. Versuchen wir es mit *Eminem*.

```{r}
#| label: LoesungAA03d2
rs[clean_name == "Eminem", .(clean_name, album)]
```

::::

\smallskip\  




:::: {.callout-tip}
# e) Welche weiblichen Bands haben mehr als 3 Mitglieder?

```{r}
#| label: LoesungAA03e
rs[artist_gender == "Female" & artist_member_count > 3, .(sort_name, clean_name)]
```


::::

\smallskip\  



:::: {.callout-tip}
# f) Welche Band hat die meisten Alben im Datensatz?

```{r}
#| label: LoesungAA03f
# zähle die Bands und sortiere absteigend
# und zeige nur die ersten 5 Reihen an
rs[, .N, by = clean_name] |> 
  _[order(-N)][1:5]
```
Bob Dylan und The Beatles haben jeweils 11 Alben in den Listen

::::

\smallskip\  




:::: {.callout-tip}
# g) Prüfen Sie per Korrelationsverfahren, ob die Beliebtheit bei Spotify (`spotify_popularity`) mit der Liste von 2020 übereinstimmt.

```{r}
#| label: LoesungAA03g
# Achtung, es sind NAs enthalten
rs[, cor(spotify_popularity, rank_2020, use="complete.obs")]
```

Es gibt einen geringen negativen Zusammenhang. Da beim Ranking ein *geringer* Wert für ein *gutes* Ranking steht, ist es auch nicht verwunderlich, dass der Zusammenhang negativ ist. Bei Spotify bedeutet ein *hoher* Wert ein gutes Ranking. Dennoch ist der Zusammenhang eher schwach.
::::

\smallskip\  




:::: {.callout-tip}
# h) Welchen durchschnittlichen Rang erzielen Alben des Genres "`Electronic`" in den Jahren 2003, 2012 und 2020?

```{r}
#| label: LoesungAA03h
# Achtung, es sind NAs enthalten
rs[genre == "Electronic", .(d2003 = mean(rank_2003, na.rm=TRUE),
                            d2012 = mean(rank_2012, na.rm=TRUE),
                            d2020 = mean(rank_2020, na.rm=TRUE)
                           )]
```

::::

\smallskip\  



:::: {.callout-tip}
# i) Berechnen Sie das arithmetische Mittel und den Median des Albenrankings für jedes Genre im Jahr 2020. Wieviele Alben sind pro Genre enthalten?

```{r}
#| label: LoesungAA03i
# Achtung, es sind NAs enthalten
rs[, .(mean = mean(rank_2020, na.rm=TRUE),
       median = as.numeric(median(rank_2020, na.rm=TRUE)),
       N = sum(!is.na(rank_2020))), by = genre] 
```

Haben Sie den 15. Eintrag `Blues/Blues ROck` bemerkt? Es ist ein Tippfehler im Datensatz enthalten.

```{r}
#| label: LoesungAA03i2
# korrigiere den Tippfehler
rs[genre == "Blues/Blues ROck", genre := "Blues/Blues Rock"]
```

Jetzt sortieren wir wie gewünscht einmal absteigend nach dem Median, und einmal aufsteigend nach `genre`.

```{r}
#| label: LoesungAA03i3
# sortiert nach Median
rs[, .(mean = mean(rank_2020, na.rm=TRUE),
       median = as.numeric(median(rank_2020, na.rm=TRUE)),
       N = sum(!is.na(rank_2020))), by = genre] |> 
  _[order(median, decreasing = TRUE)]

# sortiert nach Genre
rs[, .(mean = mean(rank_2020, na.rm=TRUE),
       median = as.numeric(median(rank_2020, na.rm=TRUE)),
       N = sum(!is.na(rank_2020))), by = genre] |> 
  _[order(genre)]
```

::::

\smallskip\  



:::: {.callout-tip}
# j) Manche Künstler haben es in jede der 3 Listen geschafft. Wie groß ist die Anzahl an Bands, die in jeder der 3 Listen vertreten sind, wieviele Alben haben in jeder der 3 Listen eine Platzierung, welche Alben sind in jeder der 3 Listen auf dem selben Platz, welche haben sich kontinuierlich verbessert, welche kontinuierlich verschlechtert?

```{r}
#| label: LoesungAA03j
# Anzahl der Bands, die in jeder der 3 Listen sind
rs[!is.na(rank_2003) & !is.na(rank_2012) & !is.na(rank_2020), 
   uniqueN(clean_name)]

# Anzahl der Alben, die in jeder der 3 Listen sind
rs[!is.na(rank_2003) & !is.na(rank_2012) & !is.na(rank_2020), 
   uniqueN(album)]

# Alben mit dem selben Ranking
rs[rank_2003 == rank_2012 & rank_2012 == rank_2020, 
   .(clean_name, album, rank_2003, rank_2012, rank_2020)]  

# Alben, die sich kontinuierlich verbessert haben
# (verbessert heisst, dass das Ranking kleiner wird)
rs[rank_2003 > rank_2012 & rank_2012 > rank_2020, 
   .(clean_name, album, rank_2003, rank_2012, rank_2020)] |>
  _[order(clean_name)] |>
  # zeige nur die ersten 10, um hier Platz zu sparen
  head(10)

# Alben, die sich kontinuierlich verschlechtert haben
# (verschlechtert heisst, dass das Ranking größer wird)
rs[rank_2003 < rank_2012 & rank_2012 < rank_2020, 
   .(clean_name, album, rank_2003, rank_2012, rank_2020)] |>
  _[order(clean_name)] |>
  # zeige nur die ersten 10, um hier Platz zu sparen
  head(10)

```
::::

\smallskip\  



:::: {.callout-tip}
# k) Erzeugen Sie eine neue Variable `soloband`, in welcher festeghalten wird, ob es sich um eine(n) Solokünstler(in) handelt (`solo`), oder um eine Band (`band`). Sind Solokünstlerinnen besser platziert als Solokünstler? Sind Bands besser platziert als Solokünstler(innen)?

```{r}
#| label: LoesungAA03k
# Solo oder Band?
rs[, soloband := fifelse(artist_member_count > 1, "band", "solo")]

# Künstlerinnen besser als Künstler?
rs[soloband=="solo", .(mean03 = mean(rank_2003, na.rm=TRUE),
                       mean12 = mean(rank_2012, na.rm=TRUE),
                       mean20 = mean(rank_2020, na.rm=TRUE)
                       ), by = artist_gender]
```
Männliche Solokünstler sind in allen 3 Listen durchschnittlich besser gerankt als weibliche.

```{r}
#| label: LoesungAA03k2

# Solo besser als Band?
rs[, .(mean03 = mean(rank_2003, na.rm=TRUE),
       mean12 = mean(rank_2012, na.rm=TRUE),
       mean20 = mean(rank_2020, na.rm=TRUE)
       ), by = soloband]
```

In den Jahren 2003 und 2012 waren Solokünstler besser gerankt als Bands, in 2020 waren Bands leicht besser.
::::

\smallskip\  


:::: {.callout-tip}
# l) Der Datensatz liegt als `wide.table` vor, da die Rankings für 2003, 2012 und 2020 als Variablen nebeneinander stehen. Wandeln Sie den Datensatz in eine `long.table` (Tidy Data) um, so dass die Rankingangaben in den Variablen `Rang` und `Rangjahr` angegeben sind.

```{r}
#| label: LoesungAA03l
# long table mit melt()
long_rs <- melt(rs, 
                measure.vars = c("rank_2003", "rank_2012", "rank_2020"),
                variable.name = "Rangjahr",
                value.name = "Rang")
# anzeigen
head(long_rs)
```
::::

\smallskip\  



:::: {.callout-tip}
# m) Plotten Sie mittels `ggplot()` die Rangveränderungen von 2003 bis 2020 für solche Alben, die sich kontinuierlich verschlechter haben. Was fällt Ihnen auf?

```{r}
#| label: LoesungAA03m
# ggplot() aktivieren
library(ggplot2)

# Daten vorsortieren
rs[rank_2003 < rank_2012 & rank_2012 < rank_2020, 
   .(album, rank_2003, rank_2012, rank_2020)] |>
  # in long-table überführen
  melt( , measure.vars = c("rank_2003", "rank_2012", "rank_2020"),
          variable.name = "Rangjahr",
          value.name = "Rang") |>
  # ggplot
  ggplot(aes(x=Rangjahr, y=Rang, color=album, group=album)) +
    geom_point() +
    geom_line() +
    ggtitle("Rolling Stone Album-Rankings über verschiedene Jahre") +
    theme(legend.position = "none")
```

Es fällt auf, dass sich die Rankings vor allem von 2012 nach 2020 deutlich verschlechtert haben.
::::

\smallskip\  








## Lösung zur Aufgabe [-@sec-AAA04] Taylor Swift {#sec-LAA04}

:::: {.callout-tip}
# a) Laden Sie den Datensatz `taylor_swift_spotify2024.csv` als `data.table` in Ihre R-Session. Nennen Sie Ihr Objekt dabei `ts` und verschaffen Sie sich mittels `str()` einen Überblick über die enthaltenen Daten.
```{r}
#| label: LoesungAA04SETUP
#| echo: false
ts <- fread("data/taylor_swift_spotify2024.csv")

```

```{r}
#| label: LoesungAA04a
#| eval: false
# falls schon gedownloadet
ts <- fread("data/taylor_swift_spotify2024.csv")

# per URL einlesen
ts <- fread("https://www.produnis.de/tabletrainer/data/taylor_swift_spotify2024.csv")
```


```{r}
#| label: LoesungAA04a2
# anschauen
str(ts)
```

::::


\smallskip\  

:::: {.callout-tip}
# b) Wenn nötig, korrigiern Sie das Skalenniveau (nominal, ordinal, metrisch) der Variablen innerhalb des Datensatzes.
```{r}
#| label: LoesungAA04b
ts[, let(name  = factor(name),
         album = factor(album),
         id    = factor(id),
         uri   = factor(uri)
        )]

# anzeigen
str(ts)
```

::::

\smallskip\  


:::: {.callout-tip}
# c) Erstellen Sie eine neue Variable `sekunden`, welche die Songlängen in Sekunden enthält 
```{r}
#| label: LoesungAA04c
ts[, sekunden := duration_ms/1000]
```

::::

\smallskip\  



:::: {.callout-tip}
# d) Wie lang dauern die Songs im Durchschnitt? Bei welcher Songlänge liegt der Median? 
```{r}
#| label: LoesungAA04d
ts[, .(Durchschnitt = mean(sekunden),
       Median = median(sekunden)
       )]
```

::::

\smallskip\  



:::: {.callout-tip}
# e) Welcher Song ist laut Datensatz der populärste, welcher der längste, und welcher der langsamste? Stellen Sie anschließend die Werte pro Album dar.
```{r}
#| label: LoesungAA04e
# populärster Song insgesamt
ts[popularity == max(popularity), name]

# populärster Song pro Album
ts[ , .SD[which.max(popularity)], by=album, .SDcols=c("name", "popularity")] |> 
  _[order(popularity, decreasing=TRUE)]

# längster Song insgesamt
ts[sekunden == max(sekunden), name]

# längster Song pro Album
ts[ , .SD[which.max(sekunden)], by=album, .SDcols=c("name", "sekunden")] |> 
  _[order(sekunden, decreasing=TRUE)]

# langsamster Song insgesamt
ts[tempo == min(tempo), name]

# langsamster Song pro Album
ts[ , .SD[which.min(tempo)], by=album, .SDcols=c("name", "tempo")] |> 
  _[order(tempo)]
```

::::

\smallskip\  



:::: {.callout-tip}
# f) Welches Album hat die meisten Songs, und welches hat die wenigsten Songs?
```{r}
#| label: LoesungAA04f
# die meisten Songs
ts[ , .N, by=album][order(-N)][1]

# die wenigsten Songs
ts[ , .N, by=album][order(N)][1]
```

::::

\smallskip\  


:::: {.callout-tip}
# g) Plotten Sie die Anzahl der Tracks pro Album als Punkt-Liniendiagramm, wobei das Datum auf der X-Achse, und die Trackanzahl auf der Y-Achse dargestellt werden.
```{r}
#| label: LoesungAA04g
# Zähle Tracks pro Album
ts[ , .N, by=release_date] |> 
  # ggplot
  ggplot(aes(x = release_date, y = N)) +
    geom_line(color = "purple") +
    geom_point(color = "purple") +
    labs(x = "Datum", 
         y = "Anzahl Tracks", 
         title = "Taylor Swift Alben")
```

::::

\smallskip\  




## Lösung zur Aufgabe [-@sec-AAA04b] Anscombe-Quartett {#sec-LAA04b}

:::: {.callout-tip}
# a) Laden Sie den Datensatz `anscombe` in Ihre R-Session und überführen Sie ihn in ein `data.table` Objekt mit dem Namen `ac`. 
```{r}
#| label: LoesungAA04Ba
# aktiviere Datensatz
data("anscombe")

# überführe in data.table "ac"
ac <- as.data.table(anscombe)
```
::::

\smallskip\  


:::: {.callout-tip}
# b) Die Daten liegen als *breite Tabelle* (wide tabel) vor. Überführen Sie sie ins *long table* (tidy) Format, so dass Ihre data.table aus den Spalten `x`, `y`, und `Gruppe` besteht.

Hierfür benutzen wir `patterns()`, um mittels *regular expression* alle Spalten auszuwählen, deren Namen mit `x` oder `y` anfangen.

```{r}
#| label: LoesungAA04Bb
# tidy data Format
lac <- melt(ac,
  measure.vars = patterns("^x", "^y"),
  value.name = c("x", "y"),           
  variable.name = "Gruppe"            
)
```
::::

\smallskip\  


:::: {.callout-tip}
# c) Berechnen Sie für jede `Gruppe` die Mittelwerte, Standardabweichungen, Korrelations- und Regressionskoeffizienten von `x` und `y`, wobei Sie Ihre Ergebnisse auf 2 Stellen runden sollen. 


```{r}
#| label: LoesungAA04Bc
# berechne Anscombe Werte
lac[, .(MittelX = round(mean(x), 2),
        StdabwX = round(sd(x), 2),
        MittelY = round(mean(y), 2),
        StdabwY = round(sd(y), 2),
        Korrela = round(cor(x, y), 2),
        Regress = round(lm(y~x)$coefficients[2], 2)
        ), by = Gruppe]
```

::: {.callout-caution appearance="simple"}
Jede Gruppe liefert die selben Werte!
:::

::::

\smallskip\  


:::: {.callout-tip}
# d) Erzeugen Sie mittels `ggplot()` eine Punktwolke mit Regressionsgeraden für jede `Gruppe`, wobei alle 4 Diagramme mit einem Plotaufruf erzeugt werden sollen. 


```{r}
#| label: LoesungAA04Bd
# plotten
ggplot(lac, aes(x=x, y=y)) +
  geom_point(color="darkblue")+
  geom_smooth(method="lm", color="red", se=FALSE) +
  facet_wrap(~Gruppe) +
  ggtitle("Anscombe Quartett")
```

::: {.callout-caution appearance="simple"}
Jede Gruppe liefert zwar die selben Kennwert, aber die Diagramme sehen nicht nur vollständig unterschiedlich aus, sie legen auch nahe, dass Ausreißer oder Messfehler die Ergebnisse verzerrt haben, und dass andere Korrelations- und Regressionsmethoden zu wählen sind.
:::

::::

::: {.callout-warning appearance="default"}
## heutzutage
Es ist nicht bekannt, wie Anscombe den Datensatz in den 1970er Jahren erstellt hat.
Heutzutage ist es mit Hilfe von evolutionären Algorithmen möglich, weit komplexere Datensätze zu erzeugen, die in ihren Kennwerten übereinstimmen, deren Streudiagramme aber beliebige Formen annehmen können.

Mein Favorit ist der Datasaurus von @matejka17.
```{r}
#| label: LoesungAA04BdatasaurusSETUP
#| echo: false
# Daten einlesen
load("data/datasaurus.RData")
```

```{r}
#| label: LoesungAA04BdatasaurusSETUPb
#| eval: false
# Daten einlesen 
load(url("https://www.produnis.de/tabletrainer/data/datasaurus.RData"))
```

```{r}
#| label: LoesungAA04Bdatasaurus
#| fig-height: 7
# plotten
ggplot(datasaurus, aes(x=x, y=y)) +
  geom_point() +
  facet_wrap(~dataset)
```

:::

\smallskip\  



## Lösung zur Aufgabe [-@sec-AAA05] Neugeborene: Rauchen {#sec-LAA05}

:::: {.callout-tip}
# a) Überführen Sie die Daten in ein `data.table`-Objekt mit dem Namen `ng`.
```{r}
#| label: LoesungAA05SETUP
#| echo: false
load("data/neonates.RData")
ng <- as.data.table(neonates)
```

```{r}
#| label: LoesungAA05a
#| eval: false
# Lade Daten
load("https://www.produnis.de/tabletrainer/data/neonates.RData")

# überführe in data.table
ng <- as.data.table(neonates)
```


```{r}
#| label: LoesungAA05a2
# anschauen
summary(ng)
```

::::

\smallskip\  

:::: {.callout-tip}
# b) Die Variabel `apgar1` enthält die APGAR-Scores nach 1 Minute. Wenn ein Score von 3 oder weniger anzeigt, dass das Neugeborene in einem kritischen Zusatand ist, wie viel Prozent der Neugeborenen in der Stichprobe sind dann in einem kritischen Zustand?
```{r}
#| label: LoesungAA05b
ng[ , .(Prozent = 100 * mean(apgar1 <= 3))]
```

7,8125% der Neugeborenen sind in einem kritischen Zustand.
::::


\smallskip\  


:::: {.callout-tip}
# c) Erstellen Sie die Häufigkeitstabelle des Geburtsgewichts der Neugeborenen, indem Sie die Daten in Klassen mit einer Breite von 0,5 kg von 2 bis 4,5 kg einteilen. Welches Intervall enthält die meisten Neugeborenen?
```{r}
#| label: LoesungAA05c
ng[, gewichtK := cut(weight, 
                     breaks=seq(2, 4.5, by=0.5), 
                     right=FALSE)] |> 
  _[, jgsbook::freqTable(gewichtK)]

```

::::


\smallskip\  



:::: {.callout-tip}
# d) Vergleichen Sie die Häufigkeitsverteilung des APGAR-Scores nach 1 Minute für Mütter unter 20 Jahren und für Mütter über 20 Jahren. Welche Gruppe hat mehr Neugeborene in kritischem Zustand?
```{r}
#| label: LoesungAA05d
# Jünger als 20
ng[age=="less than 20",  jgsbook::freqTable(apgar1)]
# Älter als 20
ng[age=="greater than 20",  jgsbook::freqTable(apgar1)]

```

In der Gruppe der unter-20-jährigen liegt der Prozentsatz an Neugeborenen mit APGAR-Werten kleiner-gleich 3 bei 12,74%. In der Gruppe der über-20-jährigen liegt der Prozentwert bei 5,51%. Es tritt also in
der Gruppe der jüngeren Mütter häufiger auf.
::::


\smallskip\  



:::: {.callout-tip}
# e) Vergleichen Sie die relative Häufigkeitsverteilung des Geburtsgewichts der Neugeborenen, je nachdem, ob die Mutter während der Schwangerschaft geraucht hat (`smoke`) oder nicht. Wenn ein Gewicht unter 2,5 kg als niedriges Gewicht gilt, welche Gruppe hat einen höheren Prozentsatz an Neugeborenen mit niedrigem Gewicht?
```{r}
#| label: LoesungAA05e
# Prozenzsatz Geburtsgewicht kleiner 2,5kg
ng[, .(Prozent = 100 * mean(weight<2.5)), by=smoke]

```

In der Gruppe der Nichtraucherinnen trat ein Geburtsgewicht kleiner 2,5kg in 2,27% der Fälle auf. Bei
den Raucherinnen waren es 17%.
::::


\smallskip\  



:::: {.callout-tip}
# f) Berechnen Sie die Prävalenz von Neugeborenen mit niedrigem Gewicht für Mütter, die vor der Schwangerschaft geraucht haben  (`smoke.before`), und den Nichtraucherinnen.
```{r}
#| label: LoesungAA05f
# Prozenzsatz Geburtsgewicht kleiner 2,5kg
ng[, .(Prozent = 100 * mean(weight<2.5)), by=smoke.before]

```

Die Prävalenz beträgt unter den Nichtraucherinnen 1,08% und unter den Raucherinnen 14,81%.
::::


\smallskip\  




:::: {.callout-tip}
# g) Berechnen Sie die Odds Ratio eines niedrigen Geburtsgewichts des Neugeborenen, wenn die Mutter während der Schwangerschaft raucht, im Vergleich dazu, wenn die Mutter nicht raucht.
```{r}
#| label: LoesungAA05g
# Kreuztabelle erzeugen
t <- dcast(ng, smoke ~ (weight < 2.5), fun=length, value.var="weight")
# in Matrix überführen
t <- as.matrix(t, rownames=TRUE)
# Odds Ratio
epitools::oddsratio(t)$measure


```

Raucherinnen haben ein 8-fach höheres Risiko ein Kind mit niedrigem Gewicht zugebären als Nichtraucherinnen. 
::::


\smallskip\  




:::: {.callout-tip}
# h) Erstellen Sie das Balkendiagramm der kumulierten relativen Häufigkeit des APGAR-Scores nach 1 Minute. Unter welchem Wert liegen die Hälfte der Neugeborenen?
```{r}
#| label: LoesungAA05h
# relative Häufigkeitstabelle
ng[, .(prop.table(table(apgar1)))] |> 
  # kumulieren
  _[, Relkum := cumsum(N)][] |>
  # an ggplot() senden
  ggplot(aes(x=apgar1, y=Relkum)) +
    geom_bar(stat="identity", col="black", fill="khaki") +
    geom_hline(yintercept = 0.5, col="indianred3")

```

Die Hälfte der Werte liegen unter **6**.
::::


\smallskip\  




:::: {.callout-tip}
# i) Vergleichen Sie die Balkendiagramme der relativen Häufigkeitsverteilungen des APGAR-Scores nach 1 Minute, je nachdem, ob die Mutter während der Schwangerschaft geraucht hat oder nicht. Welche Schlussfolgerungen können gezogen werden?
```{r}
#| label: LoesungAA05i
# relative Häufigkeitstabelle
ng[, apgar1, by=smoke] |>
  # an ggplot() senden
  ggplot(aes(x=apgar1, y=after_stat(prop)*100, fill=smoke)) +
    geom_bar(col="black", position = "dodge") +
    scale_x_continuous(breaks = c(1:9)) +
  ylab("relative Häufigkeiten")

```

Die Kinder der Raucherinnen haben geringere APGAR-Werte. Kein Kind von Raucherinnen erreicht Wert 9.
::::


\smallskip\  


:::: {.callout-tip}
# j) Berechnen Sie Median, Durchschnitt und Standardabweichung für die APGAR-Scores nach 1 und nach 5 Minuten jeweils für die Kinder von Müttern, die vor der Schwangerschaft geraucht haben, und den Nichtraucherinnen. Geben Sie auch die Anzahl an Fällen (N) an. Bewerten Sie die Ergebnisse.
```{r}
#| label: LoesungAA05j
# wähle benötigte Variablen aus
ng[, .(smoke.before, apgar1, apgar5)] |>
  # überführe in long table (tidy data)
  melt(id.vars= "smoke.before",
       measure.vars = c("apgar1", "apgar5"),
       variable.name = "Test",
       value.name = "APGAR_Score")|>
  # berechne die Kennwerte pro Gruppe
  _[, .(Median = median(APGAR_Score),
        Mittel = mean(APGAR_Score),
        StdAbw = sd(APGAR_Score),
        N = .N
       ), by = c("Test", "smoke.before")]
```
Kinder von Frauen, die vor der Schwangerschaft geraucht haben, haben zu beiden Messzeitpunkten niedrigere APGAR-Scores und eine höhere Streuung der Werte.
::::


\smallskip\  


:::: {.callout-tip}
# k) Ist der Unterschied der APGAR-Scores aus Aufgabe j) signifikant?
Testen wir zunächst auf Normalverteilung
```{r}
#| label: LoesungAA05k
# Teste apgar1 auf Normalverteilung
ng[, .(p = shapiro.test(apgar1)$p.value), by="smoke.before"]

# Teste apgar5 auf Normalverteilung
ng[, .(p = shapiro.test(apgar5)$p.value), by="smoke.before"]
```

Alle Tests sind signifikant, d.h. es liegt **keine** Normalverteilung vor. Wir dürfen also nicht den t-Test verwenden, sondern müssen den Mann-Whitney-U-Test anwenden.

```{r}
#| label: LoesungAA05k2
# Signifikanztest für APGAR1
ng[, wilcox.test(apgar1 ~ smoke.before)$p.value]

# Signifikanztest für APGAR5
ng[, wilcox.test(apgar5 ~ smoke.before)$p.value]
```
Beide Ergebnisse sind signifikant. Das bedeutet, dass der Unterschied in den APGAR-Scores zwischen Nichtraucherinnen und Müttern, die vor der Schwangerschaft geraucht haben, signifikant ist.
::::


\smallskip\  



## Lösung zur Aufgabe [-@sec-AAA06] Verteidigung gegen die dunklen Künste {#sec-LAA06}

:::: {.callout-tip}
# a) Laden Sie die Textdateien  als `data.table` in Ihre `R`-Session, und führe Sie diese zu einem einzelnen `data.table`-Objekt mit dem Namen `hp` zusammen.
```{r}
#| label: LoesungAA06SETUP
#| echo: false
lupin <- fread("data/VgddK_Lupin.txt")
moody <- fread("data/VgddK_Moody.txt")
umbri <- fread("data/VgddK_Umbridge.txt")
```

```{r}
#| label: LoesungAA06a
#| eval: false
# Lade Daten
lupin <- fread("https://www.produnis.de/tabletrainer/data/VgddK_Lupin.txt")
moody <- fread("https://www.produnis.de/tabletrainer/data/VgddK_Moody.txt")
umbri <- fread("https://www.produnis.de/tabletrainer/data/VgddK_Umbridge.txt")
```


```{r}
#| label: LoesungAA06a2
# führe zu einem Objekt "hp" zusammen
hp <- lupin[moody, on=.(Schüler=Schüler)][umbri, on=.(Schüler=Schüler)]

# anschauen
str(hp)
```

::::

\smallskip\  


:::: {.callout-tip}
# b) Erstellen Sie mit `ggplot()` ein Diagramm, welches die Leistungspunkte als Boxplots für jeden Professor darstellt. Hierfür bietet es sich an, die Daten ins `long table` Format zu überführen.
```{r}
#| label: LoesungAA06b
# Daten ins long-table-tidy-Format bringen
melt(hp, 
     id.vars = "Schüler",
     variable.name = "Professoren",
     value.name = "Leistungspunkte") |> 
  # mit ggplot() plotten
  ggplot(aes(x=Professoren, y=Leistungspunkte)) +
    geom_boxplot(fill=c("steelblue", "skyblue", "orchid")) +
    stat_boxplot(geom="errorbar") +
    ggtitle("Verteidigung gegen die dunklen Künste")
```

::::

\smallskip\  



## Lösung zur Aufgabe [-@sec-AAA07] Hogwarts Hauspunkte {#sec-LAA07}

:::: {.callout-tip}
# a) Laden Sie den Datensatz in Ihre `R`-Session, und überführen Sie ihn in eine `data.table` mit dem Namen `pp`.
```{r}
#| label: LoesungAA07SETUP
#| echo: false
load("data/PotterHauspunkte.RData")
pp <- as.data.table(PotterPunkte)
```

```{r}
#| label: LoesungAA07a
#| eval: false
# Lade Daten
load("https://www.produnis.de/tabletrainer/data/PotterHauspunkte.RData")

# überführe in data.table
pp <- as.data.table(PotterPunkte)
```


```{r}
#| label: LoesungAA07a2
# anschauen
str(pp)
```

::::

\smallskip\  


:::: {.callout-tip}
# b) Berechnen Sie Median, Mittelwert und Standardabweichung für die Hauspunkte insgesamt, und jeweils für jedes Haus und Jahr gesondert.
```{r}
#| label: LoesungAA07b
# Werte insgesamt
pp[, .(Median = median(c(Jahr1, Jahr3, Jahr5)),
       Mittel = mean(c(Jahr1, Jahr3, Jahr5)),
       Stdabw = sd(c(Jahr1, Jahr3, Jahr5))
      )]

# Werte für Haus und Schuljahr
melt(pp, 
     id.vars = "Haus",
     measure.vars = c("Jahr1", "Jahr3", "Jahr5"),
     variable.name = "Schuljahr",
     value.name = "Hauspunkte") |> 
  _[, .(Median = median(Hauspunkte),
        Mittel = mean(Hauspunkte),
        Stdabw = sd(Hauspunkte)), by = c("Haus", "Schuljahr")]

```
::::


\smallskip\  


:::: {.callout-tip}
# c) Plotten Sie die Punkte als Boxplots in Abhängigkeit zum Schuljahr, und dann in Abhängigkeit zum Haus. Verknüpfen Sie abschließend diese Bedingungen mittels `facet.wrap()`.
```{r}
#| label: LoesungAA07c
# Daten ins long-table-tidy-Format bringen
long_pp <- melt(pp, 
     id.vars = "Haus",
     measure.vars = c("Jahr1", "Jahr3", "Jahr5"),
     variable.name = "Schuljahr",
     value.name = "Hauspunkte") 

# plotte Punkte pro Schuljahr
ggplot(long_pp, aes(x=Schuljahr, y=Hauspunkte)) +
  geom_boxplot(fill=c("steelblue", "skyblue", "orchid")) +
  stat_boxplot(geom="errorbar") +
  ggtitle("Punkte für den Hauspokal")

# plotte Punkte pro Haus
ggplot(long_pp, aes(x=Haus, y=Hauspunkte)) +
  geom_boxplot(fill=c("gold", "orchid", "skyblue", "seagreen3")) +
  stat_boxplot(geom="errorbar") +
  ggtitle("Punkte für den Hauspokal")

# Kombination von beiden Bedingungen
ggplot(long_pp, aes(y=Hauspunkte, fill=Haus)) +
  geom_boxplot() +
  theme(axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(),
        legend.position = "none") +
  facet_grid(Schuljahr~Haus) +
  ggtitle("Punkte für den Hauspokal")
```

::::



\smallskip\  




## Lösung zur Aufgabe [-@sec-AAA08] Lungenkapazität {#sec-LAA08}

:::: {.callout-tip}
# a) Laden Sie den Datensatz `lungcap` als `data.table` mit dem Namen `lc` in Ihre `R`-Session

```{r}
#| label: LoesungAA08a
# Lade Daten
library(GLMsData)
data("lungcap")

# überführe in data.table
lc <- as.data.table(lungcap)

# anschauen
str(lc)
```


::::


\smallskip\  


:::: {.callout-tip}
# b) Erzeugen Sie eine neue Variable `Körpergröße`, welche die Körpergröße in Zentimetern enthält (1 Zoll =  2,54cm)

```{r}
#| label: LoesungAA08b
lc[, Körpergröße := Ht*2.54 ]
```


::::

\smallskip\  


:::: {.callout-tip}
# c) Ändern Sie die Kodierung der Variable `Smoke`, so dass statt 0 "`nein`", und statt 1 "`ja`" enthalten ist. Passen Sie dabei auch das Skalenniveau an.

```{r}
#| label: LoesungAA08c
#| eval: false
# ändere Kodierung von Smoke
lc[, Smoke := ifelse(Smoke == 1, "ja", "nein")]

# passe Skalenniveau an
lc[, Smoke := factor(Smoke)]
```


Das geht auch in einer Zeile:

```{r}
#| label: LoesungAA08c2
# ändere Kodierung und setze Factor in einem Rutsch
lc[, Smoke := factor(ifelse(Smoke == 1, "ja", "nein"))]
```


::::


\smallskip\  



:::: {.callout-tip}
# d) Plotten Sie nebeneinander die Boxplots der Lungenkapazität nichtrauchenden und rauchenden Kindern. Legt das Diagramm einen Zusammenhang nahe?

```{r}
#| label: LoesungAA08d
ggplot(lc, aes(x=Smoke, y=FEV)) +
  geom_boxplot(fill=c("darkgreen", "orchid"))
```
Es scheint, als ob rauchende Kinder eine größere Lungenkapazität hätten.
::::



\smallskip\  


:::: {.callout-tip}
# e) Führen Sie einen Signifikanztest durch, um zu überprüfen, ob sich die Lungenkapazitäten in Abhängigkeit zu `Smoke` unterscheidet.

Zunächst prüfen wir, ob die Daten in `FEV` normalverteilt sind.

```{r}
#| label: LoesungAA08e
lc[, .(p = shapiro.test(FEV)$p.value),
   by = Smoke]
```

Der Test ist signifikant, d.h. `FEV` ist nicht normalverteilt. Wir müssen daher den Mann-Whitney-U-Test verwenden.

```{r}
#| label: LoesungAA08e2
lc[, wilcox.test(FEV ~ Smoke, alternative = "greater")$p.value]
```

Der Test ist signifikant. Die Raucher haben eine größere Lungenkapazität als Nichtraucher.

::: {.callout-warning appearance="default"}
## Das sollte Sie erstmal verwundern!
Raucher haben die *besseren* Lungen?
:::

::::



\smallskip\  


:::: {.callout-tip}
# f) Erzeugen Sie eine Punktwole des Lungenvolumens und des Alters, sowie des Lungenvolumens und der Körpergröße. Legen die Diagramme einen Zusammenhang nahe?

```{r}
#| label: LoesungAA08f
#| layout-ncol: 2
scatter.smooth(lc$Age, lc$FEV, col="skyblue2")
scatter.smooth(lc$Körpergröße, lc$FEV, col="thistle")

```

Es scheint einen linearen Zusammenhang zwischen dem Alter und der Lungenkapazität sowie zwischen der Körpergröße und der Lungenkapazität zu geben.
::::



\smallskip\  


:::: {.callout-tip}
# g) Welches Regressionsmodell ist am besten geeignet, um `FEV erklärt durch Alter` zu bestimmen, und welches  ist am besten geeignet,  um `FEV erklärt durch Körpergröße` zu bestimmen?

```{r}
#| label: LoesungAA08g
# Modelle für FEV~Age
lc[, jgsbook::compare.lm(FEV, Age)]
# Modelle für FEV~Age
lc[, jgsbook::compare.lm(FEV, Körpergröße)]

```
Für `FEV erklärt durch Alter` ist ein Potenzmodell am besten geeignet. Für `FEV erklärt durch Körpergröße` ist es ein exponentielles Modell. Dabei ist R^2^ mit 0,79 größer als beim Potenzmodell des Alters (0,63).

Die Lungenkapazität wird am besten durch die Körpergröße erklärt.
::::



\smallskip\  



:::: {.callout-tip}
# h) Berechnen Sie das Modell, welches `FEV` am besten erklärt.

```{r}
#| label: LoesungAA08h
# bestimme exponentielles Modell
summary(lc[, lm(log(FEV) ~ Körpergröße)])
```
::::



\smallskip\  


:::: {.callout-tip}
# i) Plotten Sie eine Punktwolke, mit `FEV` auf der Y-Achse, und dem besten Prädiktor auf der X-Achse. Färben Sie die Daten mittels der Variable `Smoke`. Fügen Sie anschließend Ihre Modelllinie dem Plot hinzu.

Der beste Prädiktor ist `Körpergröße`.

```{r}
#| label: LoesungAA08i
# speichere Modellvorhersagen in helper Objekt
helper <- lc[, jgsbook::compare.lm(FEV, Körpergröße, predict=TRUE)]

# plotte
ggplot(lc, aes(x=Körpergröße, y=FEV)) +
  geom_point(aes(color=factor(Smoke))) +
  scale_color_manual(values=c("indianred2", "darkgreen")) +
  geom_line(data=helper, aes(x=pred.x, y=expo), color="blue")
```
::::



\smallskip\  


:::: {.callout-tip}
# j) Fügen Sie `Smoke`, `Age` und `Gender` als weitere Prädiktor dem Modell hinzu. Hat Rauchen einen Einfluss auf `FEV`?


```{r}
#| label: LoesungAA08j
# exponentielles Modell um "Smoke", "Age" und "Gender" erweitern
fit <- lc[, lm(log(FEV) ~ Körpergröße + Age + Gender + Smoke)]
summary(fit)
```


Alle Prädiktoren sind signifikant. Der Beitrag von `Smoke` ist negativ. Dies spricht dafür, dass Rauchen die Lungenkapazität verschlechtert.

```{r}
#| label: LoesungAA08j2
# Modelle vergleichen
fit0 <- lc[, lm(log(FEV) ~ Körpergröße)]
# R^2 vergleichen
summary(fit0)$r.squared - summary(fit)$r.squared 
```
Durch Hinzunahme der Prädiktoren verbessert sich R^2^, aber nur minimal.

::: {.callout-caution appearance="default"}
## zusammengefasst
Es scheint nur auf den ersten Blick so, als hätten rauchende Kinder ein *besseres* Lungevolumen als nicht-rauchende Kinder. Das liegt daran, dass 

  a) das Lungenvolumen maßgeblich von der Körpergröße abhängt, und 
  b) die jüngeren Kinder eher nicht rauchen, sonder die älteren. Diese haben dann aber auch einen größeren Körper, und somit auch ein größeres Lungenvolumen als die *kleinen* Nichtraucher.
:::
::::



\smallskip\  




## Lösung zur Aufgabe [-@sec-AAA09] Charlson-Index {#sec-LAA09}

:::: {.callout-tip}
# a) Importieren Sie den SAS-Datensatz `Krankenhausfaelle.sas` in Ihre `R`-Session und überführen Sie ihn in eine `data.table` mit dem Namen `kh`. Machen Sie sich mit dem Datensatz vertraut.
```{r}
#| label: LoesungAA09SETUP
#| echo: false
kh <- as.data.table(haven::read_sas("data/Krankenhausfaelle.sas"))
```

```{r}
#| label: LoesungAA09a
#| eval: false
# Lade Daten
tmp <- haven::read_sas("https://www.produnis.de/tabletrainer/data/Krankenhausfaelle.sas")

# überführe in data.table
kh <- as.data.table(tmp)
```


```{r}
#| label: LoesungAA09a2
# anschauen
str(kh)
```

::::

\smallskip\ 


:::: {.callout-tip}
# b) Ersetzen Sie die Kodierung der dichotomen Variablen von 0 auf `nein` und von 1 auf `ja`. Passen Sie wo nötig das Skalenniveau der Variablen an. 

```{r}
#| label: LoesungAA09b
# speichere die Namen der dichotomen Spalten in Hilfsobjekt
spalten <- names(kh)[5:17]
# kodiere dichotome Variablen in "ja/nein" um
kh[, (spalten) := lapply(.SD, \(x) fifelse(x == 1, "ja", "nein")), 
                         .SDcols = spalten]

# Alle außer "Alter" und "CHARLSON_SUM_G" müssen factor sein
spalten <- names(kh)[-c(3:4)]
# wandle in factor um
kh[, (spalten) := lapply(.SD, factor), .SDcols = spalten]

# anzeigen
str(kh)
```

::::

\smallskip\ 


:::: {.callout-tip}
# c) Klassieren Sie das Alter der Probanden und plotten Sie die relativen Häufigkeiten

Zunächst klassieren wir die Werte.
```{r}
#| label: LoesungAA09c
# klassieren
kh[, AlterK := cut(Alter, 
                   breaks=c(seq(0, 90, 10), Inf), 
                   ordered_result=TRUE,
                   right=FALSE)]
```

Jetzt können wir mittels `geom_bar()` oder `geom_histogram()` die Diagramme erzeugen.
```{r}
#| label: LoesungAA09c2
#| layout-ncol: 2

# bereite Basisplot vor
p <- ggplot(kh) +
      xlab("Altersklassen") + 
      ylab("relative Häufigkeiten") +
      scale_y_continuous(labels = scales::percent)

# plotten mit geom_bar
p + geom_bar(aes(x=AlterK, 
                 y=..prop.., group=1),
             color="black", fill="tan3")

# plotten mit geom_histogram
# benötigt die unklassierten Daten (Alter statt AlterK)
p + geom_histogram(aes(x=Alter,
                       y=..count../sum(..count..)),
                   breaks=c(seq(0, 90, 10), max(kh$Alter, na.rm=TRUE)+1), 
                   closed="left",
                   color="white", fill="tan1")

```

::::

\smallskip\ 

:::: {.callout-tip}
# d) Klassieren Sie den Charlson-Index

```{r}
#| label: LoesungAA09d
kh[, CharlsonK := cut(CHARLSON_SUM_G, 
                      breaks=c(0, 1, 3, Inf), 
                      ordered_result=TRUE,
                      right=FALSE)]
```

::::

\smallskip\ 




## Lösung zur Aufgabe [-@sec-AAA10] Neugeborene: Gewicht {#sec-LAA10}

:::: {.callout-tip}
# a) Laden Sie den SPSS-Datensatz `Neugeborene.sav` in Ihre `R`-Session und überführen Sie ihn in eine `data.table` mit dem Namen `ng2`. 
```{r}
#| label: LoesungAA10SETUP
#| echo: false
ng2 <- as.data.table(haven::read_sav("data/Neugeborene.sav"))
```

```{r}
#| label: LoesungAA10a
#| eval: false
# Lade Daten
tmp <- haven::read_sav("https://www.produnis.de/tabletrainer/data/Neugeborene.sav")

# überführe in data.table
ng2 <- as.data.table(tmp)
```


```{r}
#| label: LoesungAA10a2
# anschauen
str(ng2)
```

::::

\smallskip\ 


:::: {.callout-tip}
# b) In einigen Variablen finden Sie die Merkmalsausprägungen 9, 99 oder 999. Diese stehen für fehlende Werte und müssen in `NA` umgewandelt werden.
```{r}
#| label: LoesungAA10b

ng2[, (names(ng2)) := lapply(.SD, \(x) 
                             fifelse(x %in% c(9, 99, 999), NA, x))]
```
::::

\smallskip\  


:::: {.callout-tip}
# c) Wandeln Sie die Variable `SEX` in einen Factor mit den Levels "`männlich`" (statt 1) und "`weiblich`" (statt 2) um.
```{r}
#| label: LoesungAA10c

ng2[, SEX := fifelse(SEX == 1, "männlich", "weiblich")]
```
::::

\smallskip\  


:::: {.callout-tip}
# d) Bilden Sie aus der Variable Geburtsgewicht (`GEBGEWI`) eine neue Variable (`GEWIKAT`), welche das Geburtsgewicht den folgenden Kategorien zuordnet.
```{r}
#| label: LoesungAA10d
ng2[, GEWIKAT := cut(GEBGEWI, 
                     breaks=c(0, 2500, 3000, 3500, 4000, Inf),
                     right=TRUE,
                     ordered_result = TRUE)]
```
::::

\smallskip\  

:::: {.callout-tip}
# e) Berechnen Sie zur Variablen Geburtsgewicht die Stichprobenmerkmale getrennt für Jungen und Mädchen.
```{r}
#| label: LoesungAA10e
# alle Kennwerte liefert psych::describe()
ng2[, psych::describe(GEBGEWI, quant=c(0.05, 0.25, 0.75, 0.95), 
                      IQR=TRUE, check=F, skew=F) ,
    by = SEX]
```
::::

\smallskip\  



:::: {.callout-tip}
# f) Erstellen Sie Boxplots des Geburtsgewichts für alle Kinder, sowie separat für Jungen und Mädchen.
```{r}
#| label: LoesungAA10f
#| layout-ncol: 2
# Boxplot insgesamt
ggplot(ng2, aes(y=GEBGEWI)) +
  geom_boxplot(fill="thistle") +
  ylab("Geburtsgewicht")
# plotte nach Geschlecht getrennt
ggplot(ng2, aes(y=GEBGEWI, fill=SEX)) +
  geom_boxplot() +
  ylab("Geburtsgewicht")

```
::::

\smallskip\  


:::: {.callout-tip}
# g) Erstellen Sie zur Variable `GEWIKAT` je eine Häufigkeitstabelle und ein Säulendiagramm der relativen Häufigkeiten für a) die gesamte Stichprobe und b) unter Berücksichtigung des 2. Merkmals `SEX`
```{r}
#| label: LoesungAA10g
# Häufigkeitstabelle insgesamt
ng2[, jgsbook::freqTable(GEWIKAT)]

# Säulendiagramm insgesamt
ng2[, jgsbook::freqTable(GEWIKAT)] |>
  ggplot(aes(x=Wert, y=Relativ)) +
  geom_bar(stat="identity", fill="maroon3") +
  ylab("relative Häufigkeit")


# Häufigkeitstabelle Mädchen
ng2[SEX=="weiblich", jgsbook::freqTable(GEWIKAT)]
# Häufigkeitstabelle Jungen
ng2[SEX=="männlich", jgsbook::freqTable(GEWIKAT)]

# ggplot nach Geschlecht
ggplot(ng2, aes(x=GEWIKAT, y=after_stat(prop), 
                group=SEX, fill=SEX)) +
  geom_bar(position="dodge")+
  ylab("relative Häufigkeiten") +
  scale_y_continuous(labels = scales::percent)
```
::::

\smallskip\  



:::: {.callout-tip}
# h) Analysieren Sie den (linearen) Zusammenhang zwischen dem Geburtsgewicht [`GEBGEWI`] und der Körpergröße bei Geburt [`GEBGROE`].
```{r}
#| label: LoesungAA10h
ng2[, cor(GEBGEWI, GEBGROE, use="complete.obs")]
```
::::

\smallskip\  



:::: {.callout-tip}
# i) Einfluss des BMI
```{r}
#| label: LoesungAA10i
#  Vater und Mutter BMI
ng2[, let(VATBMI = VATGEW / (VATGROE/100)^2,
          MUTBMI = MUTGEW / (MUTGROE/100)^2
          )]

# Zusammenhang BMI prüfen
ng2[, cor(MUTBMI, VATBMI, use="complete.obs")]
```
Es gibt einen schwachen positiven Zusammenhang.
```{r}
#| label: LoesungAA10ib
# MUTBMI auf GEBGEWI
ng2[, cor(MUTBMI, GEBGEWI, use="complete.obs")]

```
Der Zusammenhang ist ebenso gering.
::::

\smallskip\  


:::: {.callout-tip}
# j) Bilden Sie aus der Variable Gewicht im Alter von 6 Wochen [`FUGEW`] und Größe im Alter von 6 Wochen [`FUGROE`] die Variable *Ponderal Index im Alter von 6 Wochen*. \newline Für Säuglinge lautet die Formel $PI = 100 \cdot \frac{g}{cm^3}$.
```{r}
#| label: LoesungAA10j
ng2[, PI := 100* (FUGEW / FUGROE^3)]
```
::::

\smallskip\  


:::: {.callout-tip}
# k) Bilden Sie eine neue Variable: Gewichtszunahme des Kindes von Geburt bis zum Alter von 6 Wochen.
```{r}
#| label: LoesungAA10k
ng2[, GEWZUN6 := FUGEW-GEBGEWI]
```
::::

\smallskip\  

:::: {.callout-tip}
# l) Bilden Sie eine neue Variable: Gewichtszunahme von Geburt bis zum Alter von 6 Wochen in % vom Geburtsgewicht.
```{r}
#| label: LoesungAA10l
ng2[, GEWZUN6P := (100*FUGEW/GEBGEWI) - 100]
```
::::

\smallskip\  



:::: {.callout-tip}
# m) Wie viele Kinder wurden gestillt ([`JSTILL`], (1,2))? Kodieren Sie zuvor die Variable um, so dass 1=`ja` und 2=`nein` wird.
```{r}
#| label: LoesungAA10m
ng2[, JSTILL := fifelse(JSTILL==1, "ja", "nein")]
ng2[, table(JSTILL)]
```
::::

\smallskip\  



:::: {.callout-tip}
# n) Vergleichen Sie die gestillten und die nicht gestillten Kinder
Vergleichen wir zunächst die Kennwerte.
```{r}
#| label: LoesungAA10n

ng2[!is.na(JSTILL),
    .(Gew6_mean = round(mean(FUGEW, na.rm = TRUE), 2),
      Gew6_sd = round(sd(FUGEW, na.rm = TRUE), 2),
      Gew6Zu_mean = round(mean(GEWZUN6, na.rm = TRUE), 2),
      Gew6Zu_sd = round(sd(GEWZUN6, na.rm = TRUE), 2),
      Gew6ZuP_mean = round(mean(GEWZUN6P, na.rm = TRUE), 2),
      Gew6ZuP_sd = round(sd(GEWZUN6P, na.rm = TRUE), 2),
      PI_mean = round(mean(PI, na.rm = TRUE), 2),
      PI_sd = round(sd(PI, na.rm = TRUE), 2)
     ), by = JSTILL]
```

Prüfen wir auf Signifikanz.
```{r}
#| label: LoesungAA10n2
# welche Variablen sollen getestet werden?
spalten <- c("FUGEW", "GEWZUN6", "GEWZUN6P", "PI")

# Signifikanztests
ng2[, lapply(.SD, function(x) wilcox.test(x ~ JSTILL)$p.value), 
             .SDcols = spalten]

```

Alle Tests sind nicht signifikant. Es gibt keinen Unterschied zwischen gestillten und nicht-gestillten Kindern.
::::

\smallskip\  


:::: {.callout-tip}
# o) Bilden Sie eine neue Variable Schwangerschaftsdauer [`SCHDAUG`] in Gesamttagen, die Sie aus den Variablen Schwangerschaftsdauer in (ganzen) Wochen (`SCHDAUW`) und Schwangerschaftsrestdauer in Tagen (`SCHDAUT`) bilden. Hat die Schwangerschaftsdauer einen Einfluss auf das Geburtsgewicht?

```{r}
#| label: LoesungAA10o
ng2[, SCHDAUG := 7*SCHDAUW + SCHDAUT]

# Korrelation
ng2[, cor(SCHDAUG, GEBGEWI, use = "complete.obs")]
```
Es gibt einen moderaten Zusammenhang zwischen Schwangerschaftsdauer und Geburtsgewicht.
::::

\smallskip\  


:::: {.callout-tip}
# p) Bilden Sie aus der Variable Nationalität der Mutter [`NATMUT`] eine neue Variable, welche die Nationalität der Mutter in 3 Kategorien zusammenfasst: `deutsch` (NATMUT=D), `türkisch` (NATMUT=TR) und `sonstige` (alle anderen, auch die ohne Angabe).

```{r}
#| label: LoesungAA10p
ng2[, NATMUTK := factor(fifelse(NATMUT == "D", "deutsch",
                        fifelse(NATMUT == "TR", "türkisch",
                                         "sonstige")))]
```

::::

\smallskip\  


:::: {.callout-tip}
# q) Unterscheiden sich die Kinder von Müttern der verschiedenen Nationalitäten hinsichtlich ihres Geburtsgewichts und ihres Ponderal Index im Alter von 6 Wochen?

```{r}
#| label: LoesungAA10q
tuerk <- ng2[NATMUTK=="türkisch"]
deuts <- ng2[NATMUTK=="deutsch"]
sonst <- ng2[NATMUTK=="sonstige"]

wilcox.test(tuerk$GEBGEWI, deuts$GEBGEWI)$p.value
wilcox.test(tuerk$GEBGEWI, sonst$GEBGEWI)$p.value
wilcox.test(deuts$GEBGEWI, sonst$GEBGEWI)$p.value

```

::::

\smallskip\  


:::: {.callout-tip}
# r) Werden die Kinder von Müttern unterschiedlicher Nationalitäten gleich häufig gestillt?

```{r}
#| label: LoesungAA10r
ng2[, xtabs(~ NATMUTK+JSTILL)]

# Chiquadrat-Test
ng2[, chisq.test(NATMUTK, JSTILL)]
# exakter Fisher-Test
ng2[, fisher.test(NATMUTK, JSTILL)]

```
Kinder unterschiedlicher Nationalitäten werden gleich häufig gestillt.
::::

\smallskip\  



:::: {.callout-tip}
# s) Vergleichen Sie das mittlere Geburtsgewicht mit der Referenz 3500g (t-Test für eine Stichprobe).

```{r}
#| label: LoesungAA10s
# t-Test
ng2[, t.test(GEBGEWI, mu=3500)]
```
Das Ergebnis ist signifikant. Das Geburtsgewicht in der Stichprobe weicht vom Referenzwert ab.
::::

\smallskip\  


:::: {.callout-tip}
# Vergleichen Sie das mittlere Geburtsgewicht von männlichen und weiblichen Neugeborenen  (t-Test für zwei Stichprobe).

```{r}
#| label: LoesungAA10t
# t-Test
ng2[, t.test(GEBGEWI ~ SEX) ]
```
Das Ergebnis ist nicht signifikant. Das Geburtsgewicht von Jungen und Mädchen unterscheidet sich nicht.
::::

\smallskip\  




